---
title: 株式と指数に対するケリー基準
free: true
---
今度は、本日の株価が与えられた時、1年後に株式（指数）が2つの値しか取らないとする株式マーケットを考えます。これも二項設定ですが、今回のモデル化に関しては、実際の株式マーケットに少し近い形です。具体的には次を想定します。
$$
p\big( r^s = μ + σ \big)= p\big( r^s = μ - σ \big)= \frac{1}{2}
$$

ここで、$E\big(r^s\big)=μ>0$ は1年間の株式の期待リターン、$σ>0$ はリターンの標準偏差（ボラティリティ）です。1年後の利用可能な資産は次のようになります。($c_0$ と $f$ は[前に定義した](chap_10_1_1)通りです。)
$$
c(f) = c_0 \cdot \big(1+(1-f) \cdot r+f \cdot r^S \big)
$$

ここで、$r$ は、株式に投資していない現金から得られる定数の短期金利です。
幾何成長率を最大化するということは、次の項を最大化するということです。
$$
G(f) = E \Big( \log \frac{c(f)}{d_0} \Big)
$$

ここで、1年に取引日が $n$ あり、各取引日$i$ ごとに次のことが成り立つとします。
$$
p \Big(r^{S}_{i} = \frac{\mu}{n} + \frac{\sigma}{\sqrt{n}} \Big) =
p \Big(r^{S}_{i} = \frac{\mu}{n} - \frac{\sigma}{\sqrt{n}} \Big) =
\frac{1}{2}
$$

ボラティリティ（標準偏差）は取引日数の平方根に比例することに注意してください。これらの仮定の下では、日次の値を先ほどの年次の値に換算すると、次のようになります。
$$
c_n(f) = c_0 \cdot \prod_{i=1}^n \Big( 1+(1-f) \cdot \frac{r}{n} + f \cdot r_{i}^S \Big)
$$

ここで、次の量を最大化すると、株式投資において長期的な資産を最大化することができます。
$$
\begin{equation} 
\begin{split}

G_n(f) &= E \Big( \log \frac{c_n(f)}{c_0} \Big) \\
&= E \Big( \sum_{i=1}^n \log \big(1+(1-f) \cdot \frac{r}{n} + f \cdot r_{i}^S \big) \Big) \\
&= \frac{1}{2} \sum_{i=1}^n \Big(\log \Big(1+(1-f) \cdot \frac{r}{n} + f \cdot  \Big( \frac{\mu}{n}+ \frac{\sigma}{\sqrt{n}} \Big) \Big) \\
&+ \log \Big( 1+(1-f) \cdot \frac{r}{n} + f \cdot  \Big( \frac{\mu}{n}+ \frac{\sigma}{\sqrt{n}} \Big) \Big) \\
\\
&= \frac{n}{2} \log \Bigg( \Big( 1+(1-f) \cdot \frac{r}{n} + f \cdot \frac{\mu}{n}     \Big)^2 - \frac{f^2 \sigma^2}{n} \Bigg)

\end{split} 
\end{equation}
$$

テイラー級数展開により、最後に次の式が得られます。
$$
G_n(f) = r +(\mu - r) \cdot f - \frac{\sigma^2}{2} \cdot f^2 + Q \Big( \frac{1}{\sqrt{n}} \Big)
$$

トレードを実行する時点が無限にある、るなわち、とぎれなく連続してトレードする場合は次の式となります。
$$
G_\infty (f) = r + ( \mu - r ) \cdot f - \frac{\sigma^2}{2} \cdot f^2
$$

このとき、1階条件から最適配分 $f^*$ は次のようになります。
$$
f^* = \frac{\mu - r}{\sigma^2}
$$
これは、株式の期待リターンから無リスク金利を差し引いた期待超過リターンを、リターンの分散で割ったものです。この式はシャープレシオに似ていますが異なるものです。
実例を用いてこれらの式の応用と、トレード戦略でエクイティにレバレッジをかける際その割合について説明します。

取り扱うトレード戦略は、単純に **S&P 500指数のパッシブなロングポジション** です。
このために、基となるデータを即座に検索し、必要な統計情報を簡単に導き出します。
```python
# return = [n=0の価格]/[n=1の価格]
data['return'] = np.log(data / data.shift(1))
data.tail()
```

|            | .SPX    | return    |
| ---------- | ------- | --------- |
| Date       |         |           |
| 2019-12-23 | 3224.01 | 0.000866  |
| 2019-12-24 | 3223.38 | -0.000195 |
| 2019-12-27 | 3240.02 | 0.000034  |
| 2019-12-30 | 3221.29 | -0.005798 |
| 2019-12-31 | 3230.78 | 0.002942  |
当該期間の `S&P 500指数` の統計的な性質から、指数のロングポジションに対しては、最適配分が役4.5 になることを示唆しています。言い換えれば、1ドルの資金に対して 4.5ドルを投資すべきであり、最適なケリー配分、あるいはこの場合は、最適なケリー係数に従った **レバレッジレシオ** が4.5であることを意味します。
すべて同じ条件なら、ケリー基準は、レバレッジが大きいほど、期待リターンが大きくボラティリティ（分散）は小さくなることを意味します。
```python
# 年間換算したリターンを算出します。252営業日
mu = data['return'].mean() * 252
# mu = 0.09992181916534204

# 年率換算したボラティリティ（標準偏差）を算出します。
sigma = data['return'].std() * 252 ** 0.5
# sigma = 0.14761569775486563

# 単純化のために投資していない現金から得られる短期金利を0に設定します。
r = 0.0

# この戦略において、投資する際の最適なケリー配分を算出します。
f = (mu - r) / sigma ** 2
f
```
> 4.585590244019818

以下のpythonコードでは、ケリー基準の適用と最適なレバレッジ比率をシュミレーションしています。単純化と比較のために、初期投資額を1に設定し、初期に投資ｓるう総資産は $1 \cdot f^*$ に設定しています。戦略に投入した資産のパフォーマンスに応じて、利用可能な資産そのものが、利用可能な資産に従って日々調整されます。損失が出た場合は資産が減り、利益が出た場合は資産が増えます。インデックスそのものと比較した株式ポジションの推移は下図にしめしています。 
```python
equs = []
def kelly_strategy(f):
    global equs
    equ = 'equity_{:.2f}'.format(f)
    equs.append(equ)
    cap = 'capital_{:.2f}'.format(f)
    
    # equiry（資本）の列を新たに生成し、初期値を1に設定します。
    data[equ] = 1
    # capital（資金）の列を生成し、初期値を1・f*に設定します。
    data[cap] = data[equ] * f
    
    for i, t in enumerate(data.index[1:]):
	    # 1つ前の値を取得します。
        t_1 = data.index[i] 
        # 収益に対し、新たな資金を計算します。
        data.loc[t, cap] = data[cap].loc[t_1] * \
                            math.exp(data['return'].loc[t])
		# 資金のパフォーマンスに応じて、資本の値を調整します。                            
        data.loc[t, equ] = data[cap].loc[t] - \
                            data[cap].loc[t_1] + \
                            data[equ].loc[t_1]
                            
		# 新しい資本と固定のレバレッジ比率を考慮して、資金を調整します。
        data.loc[t, cap] = data[equ].loc[t] * f

# fの2分の1に対してケリー基準に基づく戦略をシュミレーションします。
kelly_strategy(f * 0.5)
# fの3分の2に対してケリー基準に基づく戦略をシュミレーションします。
kelly_strategy(f * 0.66)
# fそのものに対してケリー基準に基づく戦略をシュミレーションします。
kelly_strategy(f)
```

![[images/output 1.png]]
上図が示すように、最適なケリー・レバレッジを適用すると、資本がかなり不規則に変化する（ボラティリティが高い）ことになりますが、これはレバレッジ比率が4.59であることを考えると直感的に納得できます。レバレッジが大きいほど、資本のボラティリティも大きくなると考えられます。

そのため実務者は **4.6**（フル・ケリー）ではなく**2.3**（ハーフ・ケリー）を使う事が多いです。

今回の例で、これは次のことに帰着します。
$$
\frac{1}{2} \cdot f^* = 2.3
$$
>このような背景から、上図では**4.6**（フル・ケリー）よりも低い値に対する資本の推移も示しています。

確かに $f$ の値が低いほど、リスクは減少します。

#
---
## sample code
>![[books/pythonからはじめるアルゴリズムトレード/src/ch10/10_pyalgo.ipynb]]